#pragma once
#include <cstdint>

using HTELEMETRY = void*;
using TmU16 = uint16_t;
using TmU32 = uint32_t;
using TmU64 = uint64_t;

using TmI32 = int32_t;
using TmI64 = int64_t;

enum TmOption {
  TMO_OUTPUT_DEBUG_INFO =
      0x0001,  // Print debug output to the debugger window if possible
  TMO_RECORD_TELEMETRY_STALLS =
      0x0002,  // Record stalls within Telemetry itself

  TMO_RECORD_CALLSTACKS = 0x0004,  // Record callstacks if requested

  TMO_BOOST_PRIORITY = 0x0008,  // Temporarily boost priority for Telemetry
                                // events to help with priority inversion issues

  TMO_SUPPORT_ZONES = 0x0100,     // Send zones
  TMO_SUPPORT_MESSAGES = 0x0200,  // Send messages

  TMO_SUPPORT_LOCK_STATES = 0x0400,  // Send lock states

  TMO_SUPPORT_MEMORY = 0x0800,  // Send memory events
  TMO_SUPPORT_PLOT = 0x1000,    // Send plots
  TMO_SUPPORT_BLOB = 0x2000,    // Send user blobs

  TMO_PPU_SYNCHRONIZE_SPUS = 0x4000,  // Lockstep PPU-to-SPU communication
  TMO_SUPPORT_CONTEXT_SWITCHES =
      0x8000,  // Support context switch recording on supported platforms

  TMO_NULL_NETWORK = 0x10000,  // Disable network traffic

  TMO_SUPPORT_TIMESPANS = 0x20000,  // Disable timespans

};

enum TmParameter {
  TMP_NONE = 0x0000,

  TMP_LOCK_MIN_TIME = 1,  // pass in a pointer to TmI32, >= 0 in microseconds
  TMP_DEBUG_PRINTER = 2,  // pass in a pointer to a $TmDebugPrinter
  TMP_TELEMETRY_PREFERRED_CPU =
      3,  // pass in a pointer to a TmI32 with the preferred CPU for Telemetry's
          // background thread

  TMP_USERCB_OPEN = 4,
  TMP_USERCB_CLOSE = 5,
  TMP_USERCB_WRITE = 6,
  TMP_USERCB_DATA = 7,

  TMP_EMULATED_SERVER_VERSION = 8,

  TMP_SOCKET_BUFFER_SIZE = 9,

};

enum TmServerConfiguration {
  TMSC_MEM_PLOT_THRESHOLD =
      0,  // Delta memory usage that triggers a plot for memory usage on the
          // server.  Value passed to $tmSetServerConfiguration should be a
          // 64-bit integer.
};

enum TmLockState {
  TMLS_RELEASED = 0x00000001,   // Lock was released
  TMLS_LOCKED = 0x00000002,     // Lock was acquired
  TMLS_DESTROYED = 0x00000004,  // Lock was destroyed

  TMLS_INTERNAL_MASK = 0xF0000000,
  TMLS_INTERNAL_TIMESPAN = 0x10000000,  // This is a timespan, not a lock
  TMLS_INTERNAL_LOD_LOCK =
      0x20000000,  // Internally generated by Telemetry, DO NOT USE.
  TMLS_INTERNAL_FAKE =
      0x40000000,  // Internally generated by Telemetry, DO NOT USE.
  TMLS_INTERNAL_COUNT =
      0x80000000,  // Internally generated by Telemetry, DO NOT USE.
};

enum TmLockResult {
  TMLR_SUCCESS = 0,  // Lock attempt succeeded
  TMLR_FAILED = 1,   // Lock attempt failed
  TMLR_TIMEOUT = 2,  // Lock attempt timed out
};

struct TmFormatCode {
  TmU32 fc_format;
  TmU32 fc_fbits;
  char const* fc_ptr;
};

enum TmStat {
  TMSTAT_NUM_ALLOCS_DEPRECATED,  // Number of allocs this tick
  TMSTAT_NUM_FREES_DEPRECATED,   // Number of frees this tick

  TMSTAT_NUM_TICKS_DEPRECATED,  // Number of ticks so far
};

enum TmPlotType {
  TMPT_NONE = 0,     // Display as raw float data
  TMPT_MEMORY = 1,   // Display as contextually relevant memory, i.e. bytes, kb,
                     // MB, GB, TB, etc.
  TMPT_HEX = 2,      // Display as hex value based on range
  TMPT_INTEGER = 3,  // Display as integer, no decimal points
  TMPT_UNTYPED = 3,  // Data is untyped and should be displayed as an integer
                     // (this is the same as TMPT_INTEGER)
  TMPT_PERCENTAGE_COMPUTED =
      4,  // Display as a percentage of the max, i.e. as (value-min)/(max-min),
          // computed by the client
  TMPT_PERCENTAGE_DIRECT = 5,  // Display as a percentage (i.e. 0.2187
                               // => 21.87%).  For I32/U32 it expects 0..100
  TMPT_TIME = 6,         // Display in timecode format, i.e. hh:mm:dd:ss.xxx
  TMPT_TIME_MS = 7,      // Floating point milliseconds
  TMPT_TIME_US = 8,      // Floating point microseconds
  TMPT_TIME_CLOCKS = 9,  // I64 clock cycles
  TMPT_TIME_INTERVAL =
      10,  // This plot's value should be the delta between this time and the
           // last call to tmPlot for this plot
  TMPT_USER = 128,  // Reserved for user types
  TMPT_MAX = 255
};

constexpr auto TM_MAX_CALLSTACK_DEPTH =
    32;  // This value cannot change without affecting the server protocol!!
struct TmCallStack {
  int cs_depth;
  void* cs_stack[TM_MAX_CALLSTACK_DEPTH];
};

enum TmErrorCode {
  TM_OK = 0x0000,  // Everything is okay

  TMERR_DISABLED = 0x0001,  // Telemetry has been compiled away with $NTELEMETRY
  TMERR_INVALID_CONTEXT =
      0x0002,                    // The context passed to Telemetry was invalid
  TMERR_INVALID_PARAM = 0x0003,  // Out of range, null pointer, etc.
  TMERR_OUT_OF_RESOURCES =
      0x0004,  // Typically out of available memory, string space, etc.
  TMERR_UNINITIALIZED = 0x0006,  // A Telemetry API was called before $tmStartup
  TMERR_BAD_HOSTNAME = 0x0007,   // Could not resolve hostname
  TMERR_COULD_NOT_CONNECT = 0x0008,  // Could not connect to the server
  TMERR_UNKNOWN_NETWORK = 0x0009,    // Unknown error in the networking system
  TMERR_ALREADY_SHUTDOWN = 0x000A,   // $tmShutdown called more than once
  TMERR_ARENA_TOO_SMALL =
      0x000B,  // buffer passed to $tmInitializeContext was too small
  TMERR_BAD_HANDSHAKE =
      0x000C,  // handshake with server failed (protocol error)
  TMERR_UNALIGNED =
      0x000D,  // One more more parameters were not aligned correctly
  TMERR_NETWORK_NOT_INITIALIZED =
      0x000E,  // Network startup functions were not called, e.g. WSAStartup
  TMERR_BAD_VERSION =
      0x000F,  // You're using an out of date version of the Telemetry libraries
  TMERR_BAD_TIMER =
      0x00A0,             // The provided user timer is too coarse for Telemetry
  TMERR_UNKNOWN = 0xFFFF  // Unknown error occurred
};

enum TmConnectionStatus {
  TMCS_DISCONNECTED = 0,  // Not connected to a server
  TMCS_CONNECTING = 1,    // Attempting a connection to a server
  TMCS_CONNECTED = 2      // Connected to a server
};

enum TmConnectionType {
  TMCT_TCP,   // Connect to Telemetry server over TCP/IP
  TMCT_IPC,   // Use an IPC connection (not supported on all platforms)
  TMCT_FILE,  // Store all data to local disk (not supported on all platforms)

  TMCT_USER_PROVIDED,  // Use the user defined callbacks for all file i/o
};

using tmStubCSTR = char const*;
#define tmStubRETURN_TmErrorCode return TM_OK;
#define tmStubRETURN_TmU32 return 0;
#define tmStubRETURN_void
#define tmStubRETURN_TmConnectionStatus return TMCS_DISCONNECTED;
#define tmStubRETURN_TmU64 return 0;
#define tmStubRETURN_int return 0;
#define tmStubRETURN_char return 0;
#define tmStubRETURN_TmI32 return 0;
#define tmStubRETURN_tmStubCSTR return "";

#define TM_API(ret, name, params)  \
  typedef ret(*name##Type) params; \
  ret name##Stub params {          \
    tmStubRETURN_##ret             \
  }

TM_API(TmErrorCode,
       tmCoreOpen,
       (HTELEMETRY cx,
        char const* kpAppName,
        char const* kpBuildInfo,
        char const* kpServerAddress,
        TmConnectionType const kConnection,
        TmU16 const kServerPort,
        TmU32 const kFlags,
        int const kTimeoutMS));
TM_API(TmConnectionStatus, tmCoreGetConnectionStatus, (HTELEMETRY cx));
TM_API(void, tmCoreShutdownContext, (HTELEMETRY cx));
TM_API(TmErrorCode, tmCoreGetLastError, (HTELEMETRY cx));
TM_API(TmErrorCode,
       tmCoreGetSessionName,
       (HTELEMETRY cx, char* dst, int const kDstSize));
TM_API(TmErrorCode,
       tmCoreCheckVersion,
       (HTELEMETRY cx,
        TmU32 const major,
        TmU32 const minor,
        TmU32 const build,
        TmU32 const cust));

TM_API(void, tmCoreClose, (HTELEMETRY cx));

TM_API(void, tmCoreSetDebugZoneLevel, (HTELEMETRY cx, int const v));
TM_API(void, tmCoreCheckDebugZoneLevel, (HTELEMETRY cx, int const v));
TM_API(void, tmCoreUnwindToDebugZoneLevel, (HTELEMETRY cx, int const v));

TM_API(tmStubCSTR, tmCoreDynamicString, (HTELEMETRY cx, char const* s));
TM_API(void, tmCoreClearStaticString, (HTELEMETRY cx, char const* s));

TM_API(void,
       tmCoreSetVariable,
       (HTELEMETRY cx,
        char const* kpKey,
        TmFormatCode* pFormatCode,
        char const* kpValueFmt,
        ...));
TM_API(void,
       tmCoreSetTimelineSectionName,
       (HTELEMETRY cx, TmFormatCode* pFormatCode, char const* kpFmt, ...));
TM_API(void,
       tmCoreThreadName,
       (HTELEMETRY cx,
        TmU32 const kThreadID,
        TmFormatCode* pFormatCode,
        char const* kpFmt,
        ...));
TM_API(void, tmCoreGetFormatCode, (TmFormatCode * pCode, char const* kpFmt));

TM_API(void,
       tmCoreEnable,
       (HTELEMETRY cx, TmOption const kOption, int const kValue));
TM_API(int, tmCoreIsEnabled, (HTELEMETRY cx, TmOption const kOption));

TM_API(void,
       tmCoreSetParameter,
       (HTELEMETRY cx, TmParameter const kParam, void const* kpValue));
TM_API(void,
       tmCoreSetServerConfiguration,
       (HTELEMETRY cx,
        TmServerConfiguration const kConfiguration,
        void const* kpValue));

TM_API(void, tmCoreTick, (HTELEMETRY cx));
TM_API(void, tmCoreFlush, (HTELEMETRY cx));
TM_API(void, tmCorePause, (HTELEMETRY cx, int const kPause));
TM_API(int, tmCoreIsPaused, (HTELEMETRY cx));
TM_API(void,
       tmCoreEnter,
       (HTELEMETRY cx,
        TmU64* matchid,
        TmU32 const kThreadId,
        TmU64 const kThreshold,
        TmU32 const kFlags,
        char const* kpLocation,
        TmU32 const kLine,
        TmFormatCode* pFmtCode,
        char const* kpFmt,
        ...));
TM_API(void,
       tmCoreLeave,
       (HTELEMETRY cx,
        TmU64 const kMatchID,
        TmU32 const kThreadId,
        char const* kpLocation,
        int const kLine));

TM_API(void,
       tmCoreEmitAccumulationZone,
       (HTELEMETRY cx,
        TmU64* pAccum,
        TmU64 const kZoneTotal,
        TmU32 const kCount,
        TmU32 const kZoneFlags,
        char const* kpLocation,
        TmU32 const kLine,
        TmFormatCode* pFmtCode,
        char const* kpFmt,
        ...));

TM_API(TmU64, tmCoreGetLastContextSwitchTime, (HTELEMETRY cx));

TM_API(void,
       tmCoreLockName,
       (HTELEMETRY cx,
        void const* kpPtr,
        TmFormatCode* pFmtCode,
        char const* kpFmt,
        ...));
TM_API(void,
       tmCoreSetLockState,
       (HTELEMETRY cx,
        void const* kpPtr,
        TmLockState const kState,
        char const* kLocation,
        TmU32 const kLine,
        TmFormatCode* pFormatCode,
        char const* kpFmt,
        ...));
TM_API(int,
       tmCoreSetLockStateMinTime,
       (HTELEMETRY cx,
        void* buf,
        void const* kpPtr,
        TmLockState const kState,
        char const* kLocation,
        TmU32 const kLine,
        TmFormatCode* pFormatCode,
        char const* kpFmt,
        ...));

TM_API(void,
       tmCoreBeginTimeSpan,
       (HTELEMETRY cx,
        TmU64 const kId,
        TmU32 const kFlags,
        TmU64 const kTime,
        char const* kpLocation,
        TmU32 const kLine,
        TmFormatCode* pFmtCode,
        char const* kpFmt,
        ...));
TM_API(void,
       tmCoreEndTimeSpan,
       (HTELEMETRY cx,
        TmU64 const kId,
        TmU32 const kFlags,
        TmU64 const kTime,
        char const* kpLocation,
        TmU32 const kLine,
        TmFormatCode* pFmtCode,
        char const* kpFmt,
        ...));

TM_API(void,
       tmCoreSignalLockCount,
       (HTELEMETRY cx,
        char const* kpLocation,
        TmU32 const kLine,
        void const* kPtr,
        TmU32 const kCount,
        TmFormatCode* pFmtCode,
        char const* kpName,
        ...));
TM_API(void,
       tmCoreTryLock,
       (HTELEMETRY cx,
        TmU64* matchid,
        TmU64 const kThreshold,
        char const* kpLocation,
        TmU32 const kLine,
        void const* kPtr,
        TmFormatCode* pFmtCode,
        char const* kpFmt,
        ...));
TM_API(void,
       tmCoreEndTryLock,
       (HTELEMETRY cx,
        TmU64 const kMatchId,
        char const* kpLocation,
        int const kLine,
        TmFormatCode* pFmt,
        void const* kPtr,
        TmLockResult const kResult));

TM_API(TmI32, tmCoreGetStati, (HTELEMETRY cx, TmStat const kStat));

TM_API(void,
       tmCoreMessage,
       (HTELEMETRY cx,
        TmU32 const kThreadId,
        TmU32 const kFlags,
        TmFormatCode* pFmtCode,
        char const* kpFmt,
        ...));

TM_API(void,
       tmCoreAlloc,
       (HTELEMETRY cx,
        void const* kPtr,
        TmU64 const kSize,
        char const* kpLocation,
        TmU32 const kLine,
        TmFormatCode* pFmtCode,
        char const* kpFmt,
        ...));
TM_API(void,
       tmCoreFree,
       (HTELEMETRY cx,
        void const* kpPtr,
        char const* kpLocation,
        int const kLine,
        TmFormatCode* pFmtCode));

TM_API(void,
       tmCorePlot,
       (HTELEMETRY cx,
        TmI64 const kTSC,
        TmPlotType const kType,
        TmU32 const kFlags,
        float const kValue,
        TmFormatCode* pFmtCode,
        char const* kpFmt,
        ...));
TM_API(void,
       tmCorePlotI32,
       (HTELEMETRY cx,
        TmI64 const kTSC,
        TmPlotType const kType,
        TmU32 const kFlags,
        TmI32 const kValue,
        TmFormatCode* pFmtCode,
        char const* kpFmt,
        ...));
TM_API(void,
       tmCorePlotU32,
       (HTELEMETRY cx,
        TmI64 const kTSC,
        TmPlotType const kType,
        TmU32 const kFlags,
        TmU32 const kValue,
        TmFormatCode* pFmtCode,
        char const* kpFmt,
        ...));
TM_API(void,
       tmCorePlotI64,
       (HTELEMETRY cx,
        TmI64 const kTSC,
        TmPlotType const kType,
        TmU32 const kFlags,
        TmI64 const kValue,
        TmFormatCode* pFmtCode,
        char const* kpFmt,
        ...));
TM_API(void,
       tmCorePlotU64,
       (HTELEMETRY cx,
        TmI64 const kTSC,
        TmPlotType const kType,
        TmU32 const kFlags,
        TmU64 const kValue,
        TmFormatCode* pFmtCode,
        char const* kpFmt,
        ...));
TM_API(void,
       tmCorePlotF64,
       (HTELEMETRY cx,
        TmI64 const kTSC,
        TmPlotType const kType,
        TmU32 const kFlags,
        double const kValue,
        TmFormatCode* pFmtCode,
        char const* kpFmt,
        ...));

TM_API(void,
       tmCoreBlob,
       (HTELEMETRY cx,
        void const* kpData,
        int const kDataSize,
        char const* kpPluginIdentifier,
        TmFormatCode* pFmtCode,
        char const* kpFmt,
        ...));
TM_API(void,
       tmCoreDisjointBlob,
       (HTELEMETRY cx,
        int const kNumPieces,
        void const** kpData,
        int const* kDataSize,
        char const* kpPluginIdentifier,
        TmFormatCode* pFmtCode,
        char const* kpFmt,
        ...));

TM_API(void, tmCoreUpdateSymbolData, (HTELEMETRY cx));

TM_API(int,
       tmCoreSendCallStack,
       (HTELEMETRY cx, TmCallStack const* kpCallStack, int const kSkip));
TM_API(int, tmCoreGetCallStack, (HTELEMETRY cx, TmCallStack* pCallStack));

TM_API(int,
       tmCoreSendCallStackR,
       (HTELEMETRY cx, TmCallStack const* kpCallStack, int const kSkip));
TM_API(int, tmCoreGetCallStackR, (HTELEMETRY cx, TmCallStack* pCallStack));

struct TM_API_STRUCT_STUB {
// NOTE: Order of this must be preserved, new functions should be added to the
// end
#define TM_API_S(name) name##Type name = name##Stub

  TM_API_S(tmCoreCheckVersion);
  TM_API_S(tmCoreUpdateSymbolData);
  TM_API_S(tmCoreGetLastContextSwitchTime);
  TM_API_S(tmCoreTick);
  TM_API_S(tmCoreFlush);
  TM_API_S(tmCoreDynamicString);
  TM_API_S(tmCoreClearStaticString);
  TM_API_S(tmCoreSetVariable);
  TM_API_S(tmCoreGetFormatCode);
  TM_API_S(tmCoreGetSessionName);
  TM_API_S(tmCoreGetLastError);
  TM_API_S(tmCoreShutdownContext);
  TM_API_S(tmCoreGetConnectionStatus);
  TM_API_S(tmCoreSetTimelineSectionName);
  TM_API_S(tmCoreEnable);
  TM_API_S(tmCoreIsEnabled);
  TM_API_S(tmCoreOpen);
  TM_API_S(tmCoreClose);
  TM_API_S(tmCorePause);
  TM_API_S(tmCoreIsPaused);
  TM_API_S(tmCoreEnter);
  TM_API_S(tmCoreLeave);

  TM_API_S(tmCoreThreadName);
  TM_API_S(tmCoreLockName);
  TM_API_S(tmCoreTryLock);
  TM_API_S(tmCoreEndTryLock);
  TM_API_S(tmCoreSignalLockCount);
  TM_API_S(tmCoreSetLockState);

  TM_API_S(tmCoreAlloc);
  TM_API_S(tmCoreFree);
  TM_API_S(tmCoreGetStati);

  TM_API_S(tmCoreBeginTimeSpan);
  TM_API_S(tmCoreEndTimeSpan);

  TM_API_S(tmCorePlot);
  TM_API_S(tmCorePlotI32);
  TM_API_S(tmCorePlotU32);
  TM_API_S(tmCorePlotI64);
  TM_API_S(tmCorePlotU64);
  TM_API_S(tmCorePlotF64);

  TM_API_S(tmCoreBlob);
  TM_API_S(tmCoreDisjointBlob);
  TM_API_S(tmCoreMessage);

  TM_API_S(tmCoreSendCallStack);
  TM_API_S(tmCoreGetCallStack);

  TM_API_S(tmCoreSetDebugZoneLevel);
  TM_API_S(tmCoreCheckDebugZoneLevel);
  TM_API_S(tmCoreUnwindToDebugZoneLevel);

  TM_API_S(tmCoreEmitAccumulationZone);

  TM_API_S(tmCoreSetLockStateMinTime);
  TM_API_S(tmCoreSetParameter);

  // If adding anything after here make sure to update stubs!
  TM_API_S(tmCoreSendCallStackR);
  TM_API_S(tmCoreGetCallStackR);
  TM_API_S(tmCoreSetServerConfiguration);
};
